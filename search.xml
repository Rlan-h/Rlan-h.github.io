<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nest.js请求的生命周期</title>
      <link href="/article/b57a043de6ee.html"/>
      <url>/article/b57a043de6ee.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h2><p>Nest 应用程序处理请求并按照我们所说的 <strong>请求生命周期</strong> 的顺序产生响应。使用中间件、管道、守卫和拦截器，在请求生命周期种追踪特定代码的执行位置可能会很困难，特别是当全局、控制器级和路由级组件开始发挥作用时。通常，一个请求通过中间件流到守卫，然后到拦截器，然后到管道，最后返回到返回路径上的拦截器（在生成响应时）。</p><h3 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="Middleware(中间件)"></a>Middleware(中间件)</h3><p>中间件按特定顺序执行。首先，Nest 运行全局绑定的中间件（例如绑定的中间件），然后运行模块绑定的中间件，这些中间件是在路径上确定的 app.use 。中间件按照绑定的顺序按顺序运行，类似于 Express 中的中间件工作方式。对于跨不同模块绑定的中间件，绑定到根模块的中间件将首先运行，然后中间件将按照模块添加到 imports 数组的顺序运行。</p><h3 id="Guards-守卫"><a href="#Guards-守卫" class="headerlink" title="Guards(守卫)"></a>Guards(守卫)</h3><p>防护执行从全局防护开始，然后到控制器防护，最后到路由防护。与中间件一样，守卫按绑定顺序运行。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UseGuards</span>(<span class="title class_">Guard1</span>, <span class="title class_">Guard2</span>)</span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UseGuards</span>(<span class="title class_">Guard3</span>)</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="title function_">getCats</span>(): <span class="title class_">Cats</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">getCats</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Guard1 将在之前 Guard2 执行，并且两者都将在 Guard3 之前执行。</p><div class="note no-icon flat"><p>当谈到全局绑定与控制器或本地绑定时，区别在于保护（或其他组件）的绑定位置。</p></div><div class="note no-icon flat"><p>如果通过模块使用 app.useGlobalGuard() 或提供组件，则该组件是全局绑定的。否则，如果装饰器位于控制器类之前，则它绑定到控制器，如果装饰器继续进行路由声明，则绑定到路由。</p></div><h3 id="Interceptors-拦截器"><a href="#Interceptors-拦截器" class="headerlink" title="Interceptors(拦截器)"></a>Interceptors(拦截器)</h3><p>在大多数情况下，拦截器遵循与守卫相同的模式，但有一个问题：当拦截器返回 RxJS Observables 时，可观察对象将以先进后出的方式解析。因此，入站请求将经过标准的全局、控制器、路由级解析，但请求的响应端（即从控制器方法处理程序返回后）将从路由到控制器再到全局进行解析。此外，管道、控制器或服务引发的任何错误都可以在拦截器的 catchError 运算符中读取。</p><h3 id="Pipes-管道"><a href="#Pipes-管道" class="headerlink" title="Pipes(管道)"></a>Pipes(管道)</h3><p>管道遵循标准的全局到控制器来路由绑定序列，在 @usePipes() 参数方面具有相同的先进先出顺序。但是，在路由参数级别，如果有多个管道在运行，则它们将按照最后一个参数的顺序运行，管道将运行到第一个参数。这也适用于路由级别和控制器级别管道。例如，如果我们有以下控制器：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UsePipes</span>(<span class="title class_">GeneralValidationPipe</span>)</span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UsePipes</span>(<span class="title class_">RouteSpecificPipe</span>)</span><br><span class="line">  <span class="meta">@Patch</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">updateCat</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@Body</span>() body: UpdateCatDTO,</span></span><br><span class="line"><span class="params">    <span class="meta">@Param</span>() params: UpdateCatParams,</span></span><br><span class="line"><span class="params">    <span class="meta">@Query</span>() query: UpdateCatQuery,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">updateCat</span>(body, params, query);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后 将 GeneralValidationPipe 运行 ，然后是 ，然后是 body 对象，然后移动到 RouteSpecificPipe query params ，遵循相同的顺序。如果有任何特定于参数的管道，它们将在控制器和路由级别管道之后运行（同样，从最后一个参数到第一个参数）。</p><h3 id="Filters-过滤器"><a href="#Filters-过滤器" class="headerlink" title="Filters(过滤器)"></a>Filters(过滤器)</h3><p>筛选器是唯一不首先解析全局的组件。相反，过滤器从尽可能低的级别解析，这意味着执行从任何路由绑定过滤器开始，然后继续到控制器级别，最后到全局过滤器。请注意，异常不能从一个过滤器传递到另一个过滤器;如果路由级筛选器捕获异常，则控制器或全局级筛选器无法捕获相同的异常。实现此类效果的唯一方法是在筛选器之间使用继承。</p><div class="note no-icon flat"><p>仅当在请求过程中发生任何未捕获的异常时，才会执行筛选器。</p></div><div class="note no-icon flat"><p>捕获的异常（例如使用 捕获的 try&#x2F;catch 异常）不会触发异常筛选器触发。一旦遇到未捕获的异常，生命周期的其余部分将被忽略，请求将直接跳到筛选器。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常，请求的生命周期看起来如下所示:</p><p>1.传入请求<br>2.在全局范围内绑定的中间件<br>3.模块绑定中间件<br>4.全局警卫<br>5.控制器警卫<br>6.警卫路由<br>7.全局拦截器(零部件)<br>8.控制器拦截器(零部件)<br>9.路由拦截器(零部件)<br>10.全局管道<br>11.控制器的管道<br>12.路由管道<br>13.路由参数管道<br>14.控制器(方法处理程序)<br>15.服务(如果存在)<br>16.路由拦截器(post 请求)<br>17.控制器拦截器(post 请求)<br>18.全局拦截器(post 请求)<br>19.异常过滤器(路由，然后是控制器，然后是全局)<br>20.服务器响应</p>]]></content>
      
      
      <categories>
          
          <category> Nest.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于tsconfig.json</title>
      <link href="/article/61d3bed21666.html"/>
      <url>/article/61d3bed21666.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果一个目录下存在一个 <code>tsconfig.json</code> 文件，那么它意味着这个目录是 <code>TypeScript</code> 项目的根目录。 <code>tsconfig.json</code> 文件中指定了用来编译这个项目的根文件和编译选项。</p><h2 id="使用-tsconfig-json"><a href="#使用-tsconfig-json" class="headerlink" title="使用 tsconfig.json"></a>使用 tsconfig.json</h2><ul><li>不带任何输入文件的情况下调用 <code>tsc</code>，编译器会从当前目录开始去查找 <code>tsconfig.json</code> 文件，逐级向上搜索父目录。</li><li>不带任何输入文件的情况下调用 <code>tsc</code>，且使用命令行参数 <code>--project</code> （或 <code>-p</code> ）指定一个包含 <code>tsconfig.json</code> 文件的目录。</li></ul><p>当命令行上指定了输入文件时，<code>tsconfig.json</code> 文件会被忽略。</p><h2 id="tsconfig-json各配置属性详解"><a href="#tsconfig-json各配置属性详解" class="headerlink" title="tsconfig.json各配置属性详解"></a>tsconfig.json各配置属性详解</h2><ul><li><code>compilerOptions</code>: 编译器的选项，如语言版本、目标 JavaScript 版本、生成的 sourcemap 等。</li><li><code>include</code>: 指定需要编译的文件路径或文件夹路径。</li><li><code>exclude</code>: 指定不需要编译的文件路径或文件夹路径。</li><li><code>files</code>: 指定需要编译的文件列表。</li><li><code>extends</code>: 指定继承自另一个 tsconfig.json 文件。</li><li><code>compileOnSave</code>: 指定是否在保存时编译文件。</li><li><code>buildOnSave</code>: 指定是否在保存时编译文件。</li><li><code>target</code>: 编译目标 JavaScript 版本，可以是 “ES3”，”ES5” 或 “ES2015” 等。</li><li><code>module</code>: 指定模块系统，可以是 “CommonJS”，”AMD” 或 “System” 等。</li><li><code>sourceMap</code>: 是否生成 sourcemap 文件。</li><li><code>outDir</code>: 编译输出目录。</li><li><code>rootDir</code>: 设置项目的根目录。</li><li><code>strict</code>: 是否开启严格类型检查。</li><li><code>noImplicitAny</code>: 是否禁止隐式 any 类型。</li><li><code>lib</code>: 指定要包含在编译中的库文件，如 “es2015”。</li><li><code>paths</code>: 指定模块路径别名。</li><li><code>baseUrl</code>: 指定基础目录。</li><li><code>jsx</code>: 指定 JSX 的处理方式。</li><li><code>allowJs</code>: 是否允许编译 JavaScript 文件。</li><li><code>checkJs</code>: 是否检查 JavaScript 文件。</li><li><code>declaration</code>: 是否生成声明文件。</li><li><code>declarationMap</code>: 是否生成声明文件的 sourcemap。</li><li><code>emitDecoratorMetadata</code>: 是否支持装饰器。</li><li><code>experimentalDecorators</code>: 是否支持实验性装饰器。</li><li><code>listEmittedFiles</code>: 是否列出所有输出的文件。</li><li><code>listFiles</code>: 是否列出所有编译过的文件。</li><li><code>locale</code>: 指定本地化语言。</li><li><code>mapRoot</code>: 指定 sourcemap 文件的根目录。</li><li><code>moduleResolution</code>: 指定模块解析策略。</li><li><code>noEmit</code>: 是否禁止输出 JavaScript 代码。</li><li><code>noEmitHelpers</code>: 是否禁止输出辅助函数。</li><li><code>noEmitOnError</code>: 是否在发生错误时禁止输出 JavaScript 代码。</li><li><code>noImplicitReturns</code>: 是否禁止隐式返回。</li><li><code>noUnusedLocals</code>: 是否检查未使用的局部变量。</li><li><code>noUnusedParameters</code>: 是否检查未使用的参数。</li><li><code>preserveConstEnums</code>: 是否保留 const 枚举。</li><li><code>pretty</code>: 是否格式化输出的 JavaScript 代码。</li><li><code>removeComments</code>: 是否移除注释。</li><li><code>skipLibCheck</code>: 是否跳过检查库文件。</li><li><code>sourceRoot</code>: 指定源文件的根目录。</li><li><code>suppressExcessPropertyErrors</code>: 是否禁止过多属性错误。</li><li><code>suppressImplicitAnyIndexErrors</code>: 是否禁止隐式 any 类型索引错误。</li><li><code>typeRoots</code>: 指定类型声明文件的根目录。</li><li><code>types</code>: 指定需要包含在编译中的类型声明文件。</li><li><code>watch</code>: 是否监视文件变化并重新编译。</li></ul><p>需要注意的是，tsconfig.json 中的配置属性并不是编译器的所有选项，有些选项只能在命令行中使用 –flag 的方式传入。</p><h2 id="常用选项概览"><a href="#常用选项概览" class="headerlink" title="常用选项概览"></a>常用选项概览</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span> <span class="comment">// 生成代码的 ECMAScript 目标版本</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span> <span class="comment">// 生成代码的模块标准</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es6&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 编译过程中需要引入的库文件的列表</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否编译 JS 文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否在 JS 文件中报告错误</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span> <span class="comment">// 在 .tsx 文件里支持 JSX: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否生成 .d.ts 类型定义文件</span></span><br><span class="line">    <span class="attr">&quot;emitDeclarationOnly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 只生成类型声明文件，不生成js</span></span><br><span class="line">    <span class="attr">&quot;declarationMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 为每个 .d.ts 文件生成 sourcemap</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否生成 .map 文件</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/main.js&quot;</span><span class="punctuation">,</span> <span class="comment">// 将多个输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span> <span class="comment">// 输出文件夹</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定 TypeScript 编译器查找 TypeScript 文件的根目录，通常用于控制输入文件的搜索路径。假设你的 TypeScript 文件存储在项目的根目录下，你可以配置为 &#x27;./&#x27;</span></span><br><span class="line">    <span class="attr">&quot;composite&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 生成额外的元数据文件，这些文件可以帮助构建工具（包括TypeScript自身的--build模式）更快地确定项目是否已经被构建。</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 删除注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不输出文件</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 通过 tslib 引入辅助工具函数</span></span><br><span class="line">    <span class="attr">&quot;downlevelIteration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否添加对迭代器和生成器的补丁（es6+无需关注）</span></span><br><span class="line">    <span class="attr">&quot;useDefineForClassFields&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 是否使用 Object.defineProperty 定义类实例属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 启用所有严格类型检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许隐式的 any 类型</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许把 null、undefined 赋值给其他类型变量</span></span><br><span class="line">    <span class="attr">&quot;strictFunctionTypes&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 严格检查函数的类型</span></span><br><span class="line">    <span class="attr">&quot;strictBindCallApply&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 严格检查 bind、call 和 apply 的参数规则</span></span><br><span class="line">    <span class="attr">&quot;strictPropertyInitialization&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 类的实例属性必须初始化</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不允许 this 有隐式的 any类型</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 检查未使用的局部变量</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 检查未使用的参数</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 每个分支都会有返回值</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 检查 switch 语句包含正确的 break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析 */</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 控制是否将每个文件作为单独的模块处理。</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span> <span class="comment">// 模块解析策略</span></span><br><span class="line">    <span class="attr">&quot;allowImportingTsExtensions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 允许从没有默认导出的模块中导入类型定义(.d.ts)文件</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 解析使用非相对路径导入模块时的基地址</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 模块名称到基于 baseUrl 的路径映射表</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 将多个文件夹放在一个虚拟目录下，合并多个源文件目录</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 允许从没有默认导出的模块默认导入</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 通过创建命名空间实现 CommonJS 兼容性</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 自动解析JSON文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map */</span></span><br><span class="line">    <span class="attr">&quot;sourceRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// TypeScript 源代码所在的目录</span></span><br><span class="line">    <span class="attr">&quot;mapRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 生成单个 sourcemaps 文件,而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSources&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 将代码与 sourcemaps 生成到一个文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实验性 */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 启用实验性的装饰器特性</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 为装饰器提供元数据支持</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// files可以配置一个数组列表,里面包含指定文件的相对或绝对路径,编译器在编译的时候只会编译包含在files中列出的文件,如果不指定,则取决于有没有设置include选项,如果没有include选项,则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件,而不是某个文件夹,而且不能使用* ? **/ 等通配符</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// include也可以指定要编译的路径列表,但是和files的区别在于,这里的路径可以是文件夹,也可以是文件,可以使用相对和绝对路径,而且可以使用通配符,比如&quot;./src&quot;即表示要编译src文件夹下的所有文件以及子文件夹的文件</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// exclude表示要排除的、不编译的文件,它也可以指定一个列表,规则和include一样,可以是文件或文件夹,可以是相对路径或绝对路径,可以使用通配符</span></span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// extends可以通过指定一个其他的tsconfig.json文件路径,来继承这个配置文件里的配置,继承来的文件的配置会覆盖当前文件定义的配置。TS在3.2版本开始,支持继承一个来自Node.js包的tsconfig.json配置文件</span></span><br><span class="line">    <span class="attr">&quot;compileOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// compileOnSave的值是true或false,如果设为true,在我们编辑了项目中的文件保存的时候,编辑器会根据tsconfig.json中的配置重新生成文件,不过这个要编辑器支持</span></span><br><span class="line">    <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 一个对象数组,指定要引用的项目</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ts </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JavaScript中console的内置方法</title>
      <link href="/article/3280af0d0656.html"/>
      <url>/article/3280af0d0656.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="打印调试信息"><a href="#打印调试信息" class="headerlink" title="打印调试信息"></a>打印调试信息</h2><p><strong>console.debug()</strong></p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://im.gurl.eu.org/file/50117c7a5ac73a8d8ce94.png","alt":""},{"url":"https://im.gurl.eu.org/file/89063d7e524f14fe5586d.png","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><p>浏览器日志级别：</p><ul><li>详细(Verbose)</li><li>信息(Info)</li><li>警告(Warnings)</li><li>错误(Errors)<br>通常浏览器控制台日志级别默认为默认级别(未勾选详细信息)，把浏览器日志级别勾选上详细(Verbose)，即可在控制台看见调试信息</li></ul><h2 id="打印消息"><a href="#打印消息" class="headerlink" title="打印消息"></a>打印消息</h2><h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><p><strong>console.log()</strong></p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://im.gurl.eu.org/file/2a6a64e856ed609078a59.png","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><p><strong>console.info()</strong></p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://im.gurl.eu.org/file/bb9a79aae65efbacf9062.png","alt":"看不见info信息"},{"url":"https://im.gurl.eu.org/file/dd1aba62dc43a04f41ff2.png","alt":"日志级别勾选信息之后可以可见"}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><p>不同浏览器的info样式不一样，可自行尝试</p><p><strong>console.table()</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对闭包的了解</title>
      <link href="/article/571122181dbb.html"/>
      <url>/article/571122181dbb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>首先来看一下MDN对闭包的定义：</p><div class="note no-icon flat"><p><strong>闭包</strong>（closure）是一个函数以及其捆绑的周边环境状态（<strong>Iexical environment，词法环境</strong>）的引用的组合。换而言之，<strong>闭包让开发者可以从内部函数访问外部函数的作用域</strong>。在 JavaScript 中，闭包会随着函数的创建而被同时创建</p></div><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// displayName() 是内部函数，一个闭包</span></span><br><span class="line">    <span class="title function_">alert</span>(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">displayName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p><code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。<code>displayName()</code> 是定义在 <code>init()</code> 里的内部函数，并且仅在 <code>init()</code> 函数体内可用。请注意，<code>displayName()</code> 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 <code>displayName()</code> 可以使用父函数 <code>init()</code> 中声明的变量 <code>name</code>。</p><p>运行该代码后，<code>displayName()</code> 函数内的 <code>alert()</code> 语句成功显示出了变量 <code>name</code> 的值（该变量在其父函数中声明）。这个词法作用域的例子描述了分析器如何在函数嵌套的情况下解析变量名。词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="title function_">makeFunc</span>();</span><br><span class="line"><span class="title function_">myFunc</span>();</span><br></pre></td></tr></table></figure><p>运行这段代码跟上述词法作用域示例代码效果完全一样。其中不同的的地方在于内部函数 <code>displayName()</code> 在执行前，从外部函数返回。</p><p>在一些编程语言中，一个函数中的局部变量仅存在于此函数的执行期间。一旦 <code>makeFunc()</code> 执行完毕，你可能会认为 <code>name</code> 变量将不能再被访问。然而，因为代码仍按预期运行，所以在 JavaScript 中情况显然与此不同。</p><p>原因在于，JavaScript 中的函数会形成了闭包。 闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。在本例子中，<code>myFunc</code> 是执行 <code>makeFunc</code> 时创建的 <code>displayName</code> 函数实例的引用。<code>displayName</code> 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 <code>myFunc</code> 被调用时，变量 <code>name</code> 仍然可用，其值 <code>Mozilla</code> 就被传递到 <code>alert</code> 中。</p><p>下面是一个更有意思的示例 — 一个 <code>makeAdder</code> 函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = <span class="title function_">makeAdder</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add10</span>(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> ，并返回一个新的函数。返回的函数接受一个参数 <code>y</code>，并返回<code>x+y</code> 的值。</p><p>从本质上讲，<code>makeAdder</code> 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code> 的环境中，<code>x</code> 为 5。而在 <code>add10</code> 中，<code>x</code> 则为 10。</p><h2 id="实用的闭包"><a href="#实用的闭包" class="headerlink" title="实用的闭包"></a>实用的闭包</h2><p>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p><p>因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。</p><p>在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。</p><p>假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 <code>body</code> 元素的 <code>font-size</code>，然后通过相对的 <code>em</code> 单位设置页面中其他元素（例如<code>header</code>）的字号：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的文本尺寸调整按钮可以修改 <code>body</code> 元素的 <code>font-size</code> 属性，由于我们使用相对单位，页面中的其他元素也会相应地调整。</p><p>以下是 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeSizer</span>(<span class="params">size</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = size + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = <span class="title function_">makeSizer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> size14 = <span class="title function_">makeSizer</span>(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> size16 = <span class="title function_">makeSizer</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><code>size12</code>，<code>size14</code> 和 <code>size16</code> 三个函数将分别把 <code>body</code> 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;size-12&quot;</span>).<span class="property">onclick</span> = size12;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;size-14&quot;</span>).<span class="property">onclick</span> = size14;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;size-16&quot;</span>).<span class="property">onclick</span> = size16;</span><br></pre></td></tr></table></figure><h2 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h2><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其他方法所调用。</p><p>而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p><p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为模块模式（module pattern）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure><p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：<code>Counter.increment</code>，<code>Counter.decrement</code> 和 <code>Counter.value</code>。</p><p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 <code>privateCounter</code> 的变量和名为 <code>changeBy</code> 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</p><p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 <code>privateCounter</code> 变量和 <code>changeBy</code> 函数。</p><div class="note info flat"><p><strong>备注</strong>： 你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量<code>Counter</code>。我们可以把这个函数储存在另外一个变量<code>makeCounter</code>中，并用他来创建多个计数器。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter1</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter2</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter2</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure><p>请注意两个计数器 <code>Counter1</code> 和 <code>Counter2</code> 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 <code>privateCounter</code> 。</p><p>每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。</p><div class="note info flat"><p><strong>备注</strong>： 以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。</p></div><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。</p><p>考虑以下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getMessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">getMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但我们不建议重新定义原型。可改成如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMessage</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一问-post请求可以携带params参数吗？</title>
      <link href="/article/da0a065ed6eb.html"/>
      <url>/article/da0a065ed6eb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>post请求可以携带params参数吗?</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #FFCC80;color:  #fff">查看答案    </button><div class="hide-content"><p style="font-size: 18px; font-weight: 600; color: #E53935">可以</p><p>我们使用 <code>node.js</code>+<code>express</code> 写一个简单的接口服务如下：<br>将服务挂载到了本地3000端口，定义了一个post请求接口，请求路径为 <code>/test</code>，该接口会将调用者传递的<code>params</code>和<code>body</code>参数返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">query</span>: req.<span class="property">query</span>,</span><br><span class="line">    <span class="attr">body</span>: req.<span class="property">body</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已启动&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来我们使用 <a href="https://apifox.com/">Apifox</a> 对该接口进行测试<br><img src="/img/dailyquestion/image.png"><br><img src="/img/dailyquestion/image-1.png"><br><img src="/img/dailyquestion/image-2.png"><br>可以看到，在post请求前提下，不管是params还是body参数，该接口都可以获取到并将之返回。</p></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+butterfly_Github pages搭建个人博客网站</title>
      <link href="/article/b9313b7126a9.html"/>
      <url>/article/b9313b7126a9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- # Hexo+butterfly_Github page 搭建个人博客网站 --><blockquote><p>敬请期待<br>本教程使用 Hexo框架+butterfly主题+Github page部署 进行网站搭建</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>1、访问<a href="github.com">Github</a>进行账号注册<br>2、注册之后创建一个仓库</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><strong>安装前提：</strong></p><ul><li><a href="https://nodejs.org/en">Node.js</a>(Node.js版本需不低于10.13，建议使用Node.js12.0及以上版本)<br>下载较慢可以访问<a href="https://nodejs.cn/">Node.js中文网</a></li><li><a href="https://git-scm.com/">Git</a></li></ul><p><strong>安装Git</strong></p><ul><li>Windows: 下载并安装<a href="https://git-scm.com/download/win">git</a></li><li>Mac: 使用 <a href="https://mxcl.github.com/homebrew/">Homebrew</a>，<a href="https://www.macports.org/">MacPorts</a></li><li>Linux(Ubuntu，Debian): <code>sudo apt-get install git-core</code></li><li>Linux(Fedora，Red Hat，CentOS): <code>sudo yum install git-core</code></li></ul><blockquote><p><strong>Mac用户</strong><br>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，完成后启动并进入 <strong>Preferences-&gt;Download-&gt;Command Line Tools-&gt;install</strong> 安装命令行工具</p></blockquote><blockquote><p><strong>Windows用户</strong><br>对于中国大陆地区的用户，可以前往<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包</p></blockquote><p><strong>安装Node.js</strong><br>Node.js 为大多数平台提供了官方的安装程序，对于中国大陆地区的用户，可以前往<a href="https://registry.npmmirror.com/binary.html?path=node/">淘宝 Node.js 镜像</a> 下载</p><p>其他安装方法：</p><ul><li>Windows: 通过 <a href="https://github.com/jasongin/nvs/">nvs</a>或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装</li><li>Mac: 使用 <a href="https://mxcl.github.com/homebrew/">Homebrew</a>，<a href="https://www.macports.org/">MacPorts</a></li><li>Linux:(DEB&#x2F;RPM-based): 从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装</li><li>其他: 使用响应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/zh-cn/download/package-manager">指导</a></li></ul><p>对于Mac和Linux同样建议使用 nvs 和 nvm，以避免可能会出现的权限问题</p><p><strong>安装Hexo</strong><br>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="初始化博客项目"><a href="#初始化博客项目" class="headerlink" title="初始化博客项目"></a>初始化博客项目</h2><p>新建一个文件夹，在该文件夹根目录打开cmd，使用 hexo-cli 初始化博客项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>继续安装 <a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a> 主题</p><div class="tabs" id="butterfly-install"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#butterfly-install-1">npm安装</button></li><li class="tab"><button type="button" data-href="#butterfly-install-2">Git安装(github)</button></li><li class="tab"><button type="button" data-href="#butterfly-install-3">Git安装(gitee)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="butterfly-install-1"><blockquote><p>此方法只支持 Hexo 5.0.0 以上版本<br><strong>通过npm安装并不会在themes文件夹下生成主题文件夹，而是在node_modules下生成</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-butterfly --save</span><br></pre></td></tr></table></figure><div class="note info modern"><p>升级方法：在博客项目目录下，运行 <code>npm update hexo-theme-butterfly</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="butterfly-install-2"><p><strong>稳定版</strong><br>在博客项目根目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>测试版</strong></p><blockquote><p>测试版可能存在bug，追求稳定的请安装稳定版</p></blockquote><p>如果想要安装比较新的dev分支，可以</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><div class="note info modern"><p>升级方法：在主题目录下，进行 <code>git pull</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="butterfly-install-3"><p><strong>稳定版</strong><br>在博客项目根目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>测试版</strong></p><blockquote><p>测试版可能存在bug，追求稳定的请安装稳定版</p></blockquote><p>如果想要安装比较新的dev分支，可以</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><div class="note info modern"><p>升级方法：在主题目录下，进行 <code>git pull</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><p>修改 博客项目根目录下的 <code>_config.yml(后面讲称作站点配置文件)</code>，把主题改为 <code>butterfly</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><div class="note info modern"><p>如果你是使用npm安装的butterfly主题，建议将node_modules&gt;hexo-theme-butterfly&gt;<code>_config.yml</code>复制到博客项目根目录并重命名为<code>_config.butterfly.yml(后面将称作主题配置文件)</code>,修改 <code>_config.butterfly.yml</code> 配置文件会同步到主题文件夹中的配置文件，这样可以避免后续因升级主题带来的配置数据丢失</p></div><p>如果你没有pug以及stylus的渲染器，请下载安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><strong>升级建议</strong></p><div class="note info modern"><p>升级完成后，请到Github的<a href="https://github.com/jerryc127/hexo-theme-butterfly/releases">Releases</a><br>里面有标注文件的内容（如有），请根据实际情况更新你的配置内容</p></div><p>接着一键三连</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以在浏览器中访问<a href="http://localhost:4000">http://localhost:4000</a>浏览刚搭建的博客网站</p><h2 id="网站基本信息"><a href="#网站基本信息" class="headerlink" title="网站基本信息"></a>网站基本信息</h2><div class="tabs" id="butterfly-install"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#butterfly-install-1">网站基本信息</button></li><li class="tab"><button type="button" data-href="#butterfly-install-2">参数解释</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="butterfly-install-1"><p>在 <code>_config.yml</code> 中设置网站基本信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">冉蓝の博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;记录学习|分享生活&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;我尝试初始化你，但你像是一个const变量，一经赋值就无法再次改变&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">博客</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Rlan</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <code>_config.butterfly.yml</code> 中设置页脚信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Footer Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2023</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hi,</span>  <span class="string">welcome</span>  <span class="string">to</span>  <span class="string">my</span>  <span class="string">&lt;a</span> <span class="string">href=&quot;https://butterfly.js.org/&quot;&gt;</span>  <span class="string">blog&lt;/a&gt;!</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="butterfly-install-2"><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><div style="width:20px"></div></td><td align="center"><div style="width:240px"></div></td></tr><tr><td align="center"><code>title</code></td><td align="center">网站标题</td></tr><tr><td align="center"><code>subtitle</code></td><td align="center">网站副标题</td></tr><tr><td align="center"><code>description</code></td><td align="center">网站描述</td></tr><tr><td align="center"><code>keywords</code></td><td align="center">网站关键词，支持多个</td></tr><tr><td align="center"><code>author</code></td><td align="center">网站作者</td></tr><tr><td align="center"><code>language</code></td><td align="center">网站使用的语言</td></tr><tr><td align="center"><code>timezone</code></td><td align="center">网站时区，默认使用您电脑的时区</td></tr></tbody></table><p>其中 <code>description</code> 主要用于SEO，告诉搜索引擎一个关于网站的简单描述，通常建议在其中包含网站的关键词。</p><p>页脚参数</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><div style="width:20px"></div></td><td align="center"><div style="width:240px"></div></td></tr><tr><td align="center"><code>since</code></td><td align="center">网站建立年份</td></tr><tr><td align="center"><code>suctom_text</code></td><td align="center">自定义文本</td></tr><tr><td align="center"><code>copyright</code></td><td align="center">true 展示 Hexo 和 butterfly 版权信息，false 不展示</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">    <span class="attr">startDelay:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">typeSpeed:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">backSpeed:</span> <span class="number">50</span></span><br><span class="line">  <span class="comment"># source 調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">记录学习</span> <span class="string">|</span> <span class="string">分享生活</span></span><br></pre></td></tr></table></figure><h2 id="顶部头像＆标题"><a href="#顶部头像＆标题" class="headerlink" title="顶部头像＆标题"></a>顶部头像＆标题</h2><p>在 <code>_config.butterfly.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="string">/img/nav_icon.png</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">true</span> <span class="comment"># fixed navigation bar</span></span><br></pre></td></tr></table></figure><h2 id="顶部导航栏"><a href="#顶部导航栏" class="headerlink" title="顶部导航栏"></a>顶部导航栏</h2><div class="tabs" id="butterfly-install"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#butterfly-install-1">配置信息</button></li><li class="tab"><button type="button" data-href="#butterfly-install-2">参数解释</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="butterfly-install-1"><p>在 <code>_config.butterfly.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Menu 目錄</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tag</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="string">相册:</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">  <span class="string">分享||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="string">网站:</span> <span class="string">/website/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-globe</span></span><br><span class="line">  <span class="string">心愿单:</span> <span class="string">/wish/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-star</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="butterfly-install-2"><p>格式为：&#x2F;目录&#x2F; || 图标类名<br>因内置了 <a href="https://fontawesome.com/">fontawesome</a> 图标，可以在官网中找到对应图标类名并使用<br>如希望不展示图标可以不填图标类名</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><div class="note info flat"><p>如果不希望展示顶部图，可以在 <code>_config.butterfly.yml</code> 中配置: disable_top_img: true</p></div><div class="note primary flat"><p>顶部图的获取顺序，如果都没有配置，则不显示顶部图。<br>  1、页面顶部图的获取顺序：<br>    <code>各自配置的 top_img</code> &gt; <code>配置文件 default_top_img</code><br>  2、文章页面顶部图的获取顺序：<br>    <code>各自配置的 top_img</code> &gt; <code>cover</code> &gt; <code>配置文件的 default_top_img</code></p></div><p>配置中的值：</p><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>index_img</td><td>主页的 top_img</td></tr><tr><td>default_top_img</td><td>默认的 top_img，当页面的top_img没有配置时，会显示 default_top_img</td></tr><tr><td>archive_img</td><td>归档页面的 top_img</td></tr><tr><td>tag_img</td><td>tag 子页面的默认 top_img</td></tr><tr><td>tag_per_img</td><td>tag 子页面的 top_img，可配置每个 tag 的 top_img</td></tr><tr><td>category_img</td><td>category 子页面默认的 top_img</td></tr><tr><td>category_per_img</td><td>category子页面的 top_img，可配置每个 category 的 top_img</td></tr></tbody></table><p>其他页面的(tags&#x2F;categories&#x2F;自建页面) 和 文章页的，请到对应的 md 页面设置中的 <code>top_img front_matter top_img</code><br>以上所有的 top_img 可配置以下值：</p><blockquote><p>3.2.0以下版本的配置只支持</p><ul><li>留空，true 和 false-显示默认的颜色</li><li>img链接-显示所配置的图片</li></ul></blockquote><table><thead><tr><th>配置的值</th><th>效果</th></tr></thead><tbody><tr><td>留空</td><td>显示默认的 top_img (如有)，否则显示默认的颜色（文章页top_img留空的话，会显示 cover 的值）</td></tr><tr><td>img链接</td><td>图片的链接，显示所配置的图片</td></tr><tr><td>颜色（HEX值 - #0000FFRGB值 - rgb（0，0，255，135）颜色单词 - orange渐变色 - linear-gradient（ 2deg， #E0B10FF 9%， #44F3D100 &lt;&gt;%））</td><td>对应的颜色</td></tr><tr><td>transparent</td><td>透明</td></tr><tr><td>false</td><td>不显示 top_img</td></tr></tbody></table><p><code>tag_per_img</code> 和 是 3.2.0 新增的内容，可对 tag 和 category 进行单独的配置 <code>category_per_img</code><br>并不推荐为每个 tag 和每个 category 都配置不同的顶部图，因为配置太多会拖慢生成速度</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题美化合集</title>
      <link href="/article/8d109f6dac71.html"/>
      <url>/article/8d109f6dac71.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="butterfly主题美化合集"><a href="#butterfly主题美化合集" class="headerlink" title="butterfly主题美化合集"></a>butterfly主题美化合集</h1><p>参考文章：<a href="https://blog.imzjw.cn/posts/b74f504f/index.html">小嘉的部落格</a></p><blockquote><p>敬请期待</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客主题美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于主页动画处理</title>
      <link href="/article/a83dbdc129da.html"/>
      <url>/article/a83dbdc129da.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关链接：<a href="https://zlinni.github.io/posts/1513600459/">Animation主页动画处理</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客主题美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-githubcalendar插件</title>
      <link href="/article/6c7cfbfba1d8.html"/>
      <url>/article/6c7cfbfba1d8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关链接：<a href="https://zfe.space/post/hexo-githubcalendar.html">hexo-githubcalendar插件</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文章推荐置顶轮播</title>
      <link href="/article/ff698c419b99.html"/>
      <url>/article/ff698c419b99.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关链接：<a href="https://zfe.space/post/hexo-swiper.html">文章推荐置顶轮播</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客主题美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于音乐界面</title>
      <link href="/article/b638517a5c5d.html"/>
      <url>/article/b638517a5c5d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关推荐：</p><ul><li><a href="https://blog.anheyu.com/posts/c3d3.html">给你的博客加一个优雅的音乐界面</a> </li><li><a href="https://blog.anheyu.com/posts/6c69.html">butterfly魔改aplayer音乐</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客主题美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
